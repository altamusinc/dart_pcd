import 'dart:ffi';
import 'dart:typed_data';

enum PCDFieldType {
  int, // Integer
  unsignedInt, // Unsigned Integer
  float; // Float

  @override
  String toString() {
    switch (this) {
      case PCDFieldType.int:
        return "I";
      case PCDFieldType.unsignedInt:
        return "U";
      case PCDFieldType.float:
        return "F";
    }
  }
}

enum PCDFieldLength {
  one, // 1 byte
  two, // 2 bytes
  four, // 4 bytes
  eight; // 8 bytes

  int get size {
    switch (this) {
      case PCDFieldLength.one:
        return 1;
      case PCDFieldLength.two:
        return 2;
      case PCDFieldLength.four:
        return 4;
      case PCDFieldLength.eight:
        return 8;
    }
  }

  @override
  String toString() {
    switch (this) {
      case PCDFieldLength.one:
        return "1";
      case PCDFieldLength.two:
        return "2";
      case PCDFieldLength.four:
        return "4";
      case PCDFieldLength.eight:
        return "8";
    }
  }
}

enum PCDDataType {
  ascii, // ASCII format
  binary, // Binary format
  binaryCompressed; // Compressed binary format

  @override
  String toString() {
    switch (this) {
      case PCDDataType.ascii:
        return "ascii";
      case PCDDataType.binary:
        return "binary";
      case PCDDataType.binaryCompressed:
        return "binary_compressed";
    }
  }
}
class PCD {
  List<List<num>> points;
  late PCDHeader header;


  // Feed XYZ points, expects points to be 3 values long, errors if not. Autodetects float or int and assumes 4 bytes for each.
  PCD.fromXYZPoints(this.points)
  {
    if (points.isEmpty || points[0].length != 3) {
      throw Exception("Points must be a list of lists with exactly 3 values each.");
    }
    var fields = ["x", "y", "z"];
    var sizes = List.filled(3, PCDFieldLength.four);
    var types = detectDataTypeFromPoint(points[0]);
    if (types.length != 3) {
      throw Exception("Detected types do not match expected number of fields.");
    }
    header = PCDHeader(fields, sizes, types, points.length, 1, points.length);
  }

  
  // Feed XYZI points, expects points to be 4 values long, errors if not. Autodetects float or int and assumes 4 bytes for each.
  PCD.fromXYZIPoints(this.points)
  {
    if (points.isEmpty || points[0].length != 4) {
      throw Exception("Points must be a list of lists with exactly 4 values each.");
    }
    var fields = ["x", "y", "z", "intensity"];
    var sizes = List.filled(4, PCDFieldLength.four);
    var types = detectDataTypeFromPoint(points[0]);
    if (types.length != 4) {
      throw Exception("Detected types do not match expected number of fields.");
    }
    header = PCDHeader(fields, sizes, types, points.length, 1, points.length);
  }

  // Roll your own; feed points, field names, and datatypes
  PCD.fromPoints({required this.points, required List<String> fieldNames, required List<PCDFieldType> fieldTypes, required List<PCDFieldLength> fieldLengths})
  {
    if (points.isEmpty) {
      throw Exception("Points must not be empty.");
    }
    if (!(fieldNames.length == fieldTypes.length && fieldNames.length == fieldLengths.length)) {
      throw Exception("Field names, types, and lengths must all have the same length.");
    }
    if (fieldNames.length != points[0].length) {
      throw Exception("Points must have same number of fields as field names.");
    }
    
    header = PCDHeader(fieldNames, fieldLengths, fieldTypes, points.length, 1, points.length);
  }

  List<PCDFieldType> detectDataTypeFromPoint(List<num> point) {
    List<PCDFieldType> types = [];
    for (final field in point) {
      if (field is int) {
        types.add(PCDFieldType.int);
      } else if (field is double) {
        types.add(PCDFieldType.float);
      } else {
        throw Exception("Unsupported data type: ${field.runtimeType}");
      }
    }
    return types;
  }

  @override
  String toString(){
    String s = header.toString();
    for(final point in points)
    {
      String p = ""; // String for the row representing this point
      for (final field in point)
      {
        p += "${field.toString()} "; // fill out the row
      }
      s += "${p.trim()} \n"; // Add it to the string.
    }
    return s;
  }
}

class PCDHeader {
  String _comments = "";
  final String _fixedComment = "Generated by dart_pcd on ${DateTime.now()}}";
  String version = ".7";
  List<String> fields;
  List<PCDFieldLength> size;
  List<PCDFieldType> type;
  List<num> count;
  int width;
  int height;
  List<int> viewpoint = [0, 0, 0, 1, 0, 0, 0];
  int points;
  PCDDataType dataType = PCDDataType.ascii;
  PCDHeader(
    this.fields,
    this.size,
    this.type,
    this.width,
    this.height,
    this.points,
  ) : count = List<int>.filled(fields.length, 1);

  void addComment(String comment) {
    _comments += comment;
  }

  void clearComments() {
    _comments = "";
  }

  String _buildComments() {
    String commentsStr = "";
    if (_comments.isNotEmpty) {
      var commentLines = _comments.split('\n');
      for (final line in commentLines) {
        commentsStr += "# $line\n";
      }
    }

    commentsStr += "# $_fixedComment";
    return commentsStr;
  }
  @override
  String toString() {
    String fieldsStr = "";
    for (final field in fields) {
      fieldsStr += "$field ";
    }
    String sizeStr = "";
    for (final s in size) {
      sizeStr += "${s.toString().trim()} ";
    }
    String typeStr = "";
    for (final t in type) {
      typeStr += "$t ";
    }
    String countStr = "";
    for (final c in count) {
      countStr += "${c.toString()} ";
    }
    String viewpointStr = "";
    for (final v in viewpoint) {
      viewpointStr += "${v.toString()} ";
    }

    String comments = _buildComments();
    String s = '''
$comments
VERSION $version
FIELDS $fieldsStr
SIZE $sizeStr
TYPE $typeStr
COUNT $countStr
WIDTH $width
HEIGHT $height
VIEWPOINT $viewpointStr
POINTS $points
DATA $dataType\n''';
    return s;
  }
}
